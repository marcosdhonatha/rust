# What is Ownership?

Ownership is a discipline for ensuring the **safety** of Rust programs. To understand ownership, we first need to understand what makes a Rust program safe (or unsafe).

> Safety is the Absence of Undefined Behavior

Rust’s goal is to compile programs into efficient binaries that require
as few runtime checks as possible. Therefore Rust does not check at *runtime* whether a variable is defined before being used. Instead, Rust checks at *compile-time*.


**A foundational goal of Rust is to ensure that your programs never have undefined behavior.**


That is the meaning of “safety.” Undefined behavior is especially
dangerous for low-level programs with direct access to memory. About [70% of reported security vulnerabilities](https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/) in low-level systems are caused by memory corruption, which is one form of undefined behavior.

A secondary goal of Rust is to prevent undefined behavior at *compile-time* instead of *run-time* . This goal has two motivations:

1. Catching bugs at compile-time means avoiding those bugs in production, improving the reliability of your software.
2. Catching bugs at compile-time means fewer runtime checks for those bugs, improving the performance of your software.

Rust cannot prevent all bugs. If an application exposes a public and unauthenticated `/delete-production-database`
endpoint, then a malicious actor doesn’t need a suspicious if-statement
to delete the database. But Rust’s protections are still likely to make
programs safer versus using a language with fewer protections, e.g. as
found by [Google’s Android team](https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html).

## Ownership as a Discipline for Memory Safety

### Variables Live in the Stack

Variables live in **frames** . A frame is a mapping from variables to values within a single scope, such as a function. Frames are organized into a **stack** of currently-called-functions.

### Boxes Live in the Heap

To transfer access to data without copying it, Rust uses **pointers** . A pointer is a value that describes a location in memory. The value that a pointer points-to is called its **pointee.** One common way to make a pointer is to allocate memory in the **heap** .
The heap is a separate region of memory where data can live
indefinitely. Heap data is not tied to a specific stack frame. Rust
provides a construct called [`Box`](https://doc.rust-lang.org/std/boxed/index.html) for putting data on the heap.

### Summary

Ownership is primarily a discipline of heap management:

* All heap data must be owned by exactly one variable.
* Rust deallocates heap data once its owner goes out of scope.
* Ownership can be transferred by moves, which happen on assignments and function calls.
* Heap data can only be accessed through its current owner, not a previous owner.

We have emphasized not just *how* Rust’s safeguards work, but *why*
they avoid undefined behavior. When you get an error message from the
Rust compiler, it’s easy to get frustrated if you don’t understand why
Rust is complaining. These conceptual foundations should help you with
interpreting Rust’s error messages.  They should also help you design
more Rustic APIs.
